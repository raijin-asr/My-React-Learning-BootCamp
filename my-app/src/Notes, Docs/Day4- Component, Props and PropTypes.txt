----------Components:---from react docs
--Conceptually, components are like JavaScript functions. They accept arbitrary inputs (called “props”) and return React elements describing what should appear on the screen.

--Components let you split the UI into independent, reusable pieces, and think about each piece in isolation. 

--The simplest way to define a component is to write a JavaScript function:

    function Welcome(props) {
    return <h1>Hello, {props.name}</h1>;
    }

--You can also use an ES6 class to define a component:

    class Welcome extends React.Component {
    render() {
        return <h1>Hello, {this.props.name}</h1>;
    }
    }

--Rendering a Component:
Previously, we only encountered React elements that represent DOM tags:

    const element = <div />;

However, elements can also represent user-defined components:

    const element = <Welcome name="Sara" />;
-For example, this code renders “Hello, Sara” on the page:

    function Welcome(props) {
    return <h1>Hello, {props.name}</h1>;
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    const element = <Welcome name="Sara" />;
    root.render(element);

--Composing Components:
Components can refer to other components in their output. This lets us use the same component abstraction for any level of detail. A button, a form, a dialog, a screen: in React apps, all those are commonly expressed as components

For example, we can create an App component that renders Welcome many times:

    function Welcome(props) {
    return <h1>Hello, {props.name}</h1>;
    }

    function App() {
    return (
        <div>
        <Welcome name="Ram" />
        <Welcome name="Shyam" />
        <Welcome name="Hari" />
        </div>
    );
    }

--Extracting Components
Don’t be afraid to split components into smaller components.

    function formatDate(date) {
    return date.toLocaleDateString();
    }

    function Comment(props) {
    return (
        <div className="Comment">
        <div className="UserInfo">
            <img className="Avatar"
                src={props.author.avatarUrl}
                alt={props.author.name} />
            <div className="UserInfo-name">
            {props.author.name}
            </div>
        </div>
        <div className="Comment-text">
            {props.text}
        </div>
        <div className="Comment-date">
            {formatDate(props.date)}
        </div>
        </div>
    );
    }

    const comment = {
    date: new Date(),
    text: 'Learning React!',
    author: {
        name: 'Ameer',
        avatarUrl: '.\logo192'
    }
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(
    <Comment
        date={comment.date}
        text={comment.text}
        author={comment.author} />
    );

--First, we will extract Avatar:

    function Avatar(props) {
    return (
        <img className="Avatar"
        src={props.user.avatarUrl}
        alt={props.user.name}
        />
    );
    }
The Avatar doesn’t need to know that it is being rendered inside a Comment. This is why we have given its prop a more generic name: user rather than author.

We recommend naming props from the component’s own point of view rather than the context in which it is being used.

We can now simplify Comment a tiny bit:

    function Comment(props) {
    return (
        <div className="Comment">
        <div className="UserInfo">
            <Avatar user={props.author} />
            <div className="UserInfo-name">
            {props.author.name}
            </div>
        </div>
        <div className="Comment-text">
            {props.text}
        </div>
        <div className="Comment-date">
            {formatDate(props.date)}
        </div>
        </div>
    );
    }

--Next, we will extract a UserInfo component that renders an Avatar next to the user’s name:

    function UserInfo(props) {
    return (
        <div className="UserInfo">
        <Avatar user={props.user} />
        <div className="UserInfo-name">
            {props.user.name}
        </div>
        </div>
    );
    }
This lets us simplify Comment even further:

    function Comment(props) {
    return (
        <div className="Comment">
        <UserInfo user={props.author} />
        <div className="Comment-text">
            {props.text}
        </div>
        <div className="Comment-date">
            {formatDate(props.date)}
        </div>
        </div>
    );
    }

--Props are Read-Only---
Whether you declare a component as a function or a class, it must never modify its own props. Consider this sum function:

    function sum(a, b) {
    return a + b;
    }
Such functions are called “pure” because they do not attempt to change their inputs, and always return the same result for the same inputs.

In contrast, this function is impure because it changes its own input:

    function withdraw(account, amount) {
    account.total -= amount;
    }
React is pretty flexible but it has a single strict rule:

All React components must act like pure functions with respect to their props.

Of course, application UIs are dynamic and change over time

-----------------------------from yt